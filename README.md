## SimpleTensor

### Tensor 是什么

Tensor 可以理解为可变维数的数组，可以根据用户所需要的维数进行使用。但又不只是数组。它还能够进行一些运算操作。

我们的实现基本上是模拟 Pytorch 中的 Tensor 操作。

### Tensor 中数据的存储

为了方便存储数据，我们将所有高维数据压平到一维去存储，并辅助一个形状数组，表示每一个维度大小。

#### 数据

由于数据的共享性，这里在 `allocateor.h` 和 `array.h` 里面实现了一个共享指针（`shared_ptr`）的数组，以此来实现数据存储的共享。

数据存储的声明和实现分别在 `storage.h` 和 `storage.cpp` 里，定义一个类 `Storage` 以表示数据的存储。

每个 `Storage` 里有两个指针，一个是以一个结构体为类型的共享的基指针 `b_ptr`，这个结构体里只有一个长度为 1 的数组，表示数据；一个是浮动的普通指针 `f_ptr`，用于访问这里面的数据。除此之外，还有一个 `offset` 表示这二者的偏差。通常情况下，二者应该是相等的，但是，经过某些操作变换之后，会导致二者不一样，同时 `offset` 也会不等于 0。

#### 形状

同时，每一个张量形状是唯一的，所以用唯一指针（`unique_ptr`）实现这个数组。形状的声明和实现分别在 `shape.h` 与 `shape.cpp` 中，定义一个类 `Shape` 以表示形状。

#### 步长

为了能够更加方便的遍历、处理和输出这个张量，额外引入一个步长的概念。步长是对每一维而言，将给出的多维坐标的形式转化为一维的内存中的位置。

在构造的时候，第 $i$ 维的步长就是 $i+1$ 维到第 $k$ 维的大小乘积，即

$$
stide_i = \prod _{j = i+1}^kshape_j
$$

最后一维第 $k$ 维的步长为 $1$。这样，对于一个 $k$ 维坐标 $(a_1,a_2,\cdots,a_k)$ 对应到的一维即为 
$$
\begin{split}
x &= a_1\times stride_1+a_2\times stride_2+\cdots+a_{k-1}\times stride_{k-1}+a_k\times stride_k\\
&= \prod_{i = 1}^ka_i\times stride_i
\end{split}
$$

### Tensor 的基本运算

#### 转置 transpose

#### 变换形状 view

#### 形状的重排 permute

#### 索引和切片 slice

### Tensor 的数值运算

#### 加法/减法

#### 数乘

#### 点乘

#### 矩阵乘法